
import java.awt.*;
import java.awt.geom.*;
import javax.swing.*;

/**
 * JMath.java
 *
 * JPanel mit math. Koordinatensystem. Über die Schnittstelle
 * MathPainter kann mit Java2D-Genauigkeit gezeichnet werden.
 * 
 * @author Prof. Dr. C. Hentschel
 * @version 1.8 (2016-11-15)
 */
public class JMath extends JPanel {

    protected int unit = 30; // Pixel pro Einheit
    protected int zeroX, zeroY = Integer.MAX_VALUE; // Nullpunkt-Koordinaten
    protected double mathMinX, mathMaxX;
    protected double mathMinY, mathMaxY;
    protected boolean axis;
    protected boolean enableMouse;
    private MathPainter paintClient;
    private boolean needRepaint;

    /**
     * Creates new form JMath
     */
    public JMath() {
        super();
        
        initComponents();
        axis = true;
        enableMouse = true;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setPreferredSize(new java.awt.Dimension(400, 300));
        addMouseWheelListener(new java.awt.event.MouseWheelListener() {
            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
                formMouseWheelMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseWheelMoved(java.awt.event.MouseWheelEvent evt) {//GEN-FIRST:event_formMouseWheelMoved
        if (enableMouse == false)
            return;
        
        int clicks = evt.getWheelRotation();
        int nUnit = unit - clicks;

        if (nUnit > 3 && nUnit < getSize().width) {
            unit = nUnit;
        }
        repaint();

    }//GEN-LAST:event_formMouseWheelMoved

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
        initTransformation();
        repaint();
    }//GEN-LAST:event_formComponentResized

    private boolean zeroIsMoved;
    private int actX, actY;
    
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        if (enableMouse == false)
            return;
        
        if (evt.getX() <= zeroX + 4 && evt.getX() >= zeroX - 4
                && evt.getY() <= zeroY + 4 && evt.getY() >= zeroY - 4) {
            actX = evt.getX();
            actY = evt.getY();
            zeroIsMoved = true;
            repaint();
        }
    }//GEN-LAST:event_formMousePressed

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        zeroIsMoved = false;
        repaint();
    }//GEN-LAST:event_formMouseReleased

    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        if (enableMouse == false)
            return;
        
        if (zeroIsMoved == false)
            return;
        
        zeroX -= actX - evt.getX();
        zeroY -= actY - evt.getY();
        
        actX = evt.getX();
        actY = evt.getY();
        repaint();
    }//GEN-LAST:event_formMouseDragged
    
    private AffineTransform tr, noneTr;

    @Override
    public void paint(Graphics g) {
        super.paint(g);

        Graphics2D g2d = (Graphics2D) g;
        tr = new AffineTransform();

        // Berechne Min/Max-Werte der Koordinatenachsen
        initTransformation();

        // Festlegen der Transformation
        tr.translate(zeroX, zeroY);
        tr.scale(unit, -unit);
        noneTr = g2d.getTransform();
        g2d.transform(tr);
        // Linienstärke anpassen
        g2d.setStroke(new BasicStroke(1.0F / unit));
        g2d.setRenderingHint(
            RenderingHints.KEY_ANTIALIASING,
            RenderingHints.VALUE_ANTIALIAS_ON
        );

        // Zeichnen der Koordinatenachsen
        if (axis == true) {
            if (zeroIsMoved)
                g2d.setColor(Color.red);
            else
                g2d.setColor(Color.black);
            drawAxis(g2d);
        }

        // Zusätze zeichnen lassen (in math. Koordinaten)
        if (paintClient != null) {
            paintClient.mathPaint(g2d);
        }

        g2d.setTransform(noneTr);
        tr = noneTr = null;
    }

    /**
     * Gibt einen String an der angegebenen math. Position (x,y) aus.
     * 
     * @param g : das Graphics2D-Object
     * @param str : der auszugebene String
     * @param x : die math. x-Koordinate
     * @param y : die math. y-Koordinate 
     */
    public void drawString(Graphics2D g, String str, double x, double y) {
        if (noneTr == null || tr == null) {
            return;
        }

        float sx = (float) (x * unit + zeroX);
        float sy = (float) (zeroY - y * unit);

        g.setRenderingHint(
            RenderingHints.KEY_TEXT_ANTIALIASING,
            RenderingHints.VALUE_TEXT_ANTIALIAS_ON
        );
        g.setTransform(noneTr);
        g.drawString(str, sx, sy);
        g.setTransform(tr);
    }

    /**
     * Gibt ein Bild an der angegebenen math. Position (x,y) aus.
     * 
     * @param g : das Graphics2D-Object
     * @param img : ddas Image-Objekt
     * @param x : die math. x-Koordinate
     * @param y : die math. y-Koordinate 
     */
    public void drawImage(Graphics2D g, Image img, double x, double y) {
        if (noneTr == null || tr == null && img != null) {
            return;
        }

        float sx = (float) (x * unit + zeroX);
        float sy = (float) (zeroY - y * unit);

        g.setTransform(noneTr);
        AffineTransform itr = new AffineTransform();
        itr.translate(sx, sy);
        g.drawImage(img, itr, this);//, sx, sy);
        g.setTransform(tr);
    }

    /**
     * Gibt ein Bild an der angegebenen math. Position (x,y) aus,
     * wobei es auf die angegebene Breite und H&ouml;he skaliert wird.
     * 
     * @param g : das Graphics2D-Object
     * @param img : ddas Image-Objekt
     * @param x : die math. x-Koordinate
     * @param y : die math. y-Koordinate 
     * @param w : die Breite des Bildes in math. L&auml;nge
     * @param h : die H&ouml;he des Bildes in math. L&auml;nge
     */
    public void drawImage(Graphics2D g, Image img, double x, double y, double w, double h) {
        if (noneTr == null || tr == null && img != null) {
            return;
        }

        int width = (int) (w * unit);
        int height = (int) (h * unit);

        Image sizedImage = img.getScaledInstance(width, height, Image.SCALE_DEFAULT);
        if (sizedImage != null) {
            MediaTracker tracker = new MediaTracker(this);
            tracker.addImage(sizedImage, 0);
            try {
                tracker.waitForAll();
            } catch (InterruptedException e) {
            }

            drawImage(g, sizedImage, x, y);
        }
    }

    /**
     * Gibt ein Bild an der angegebenen math. Position (x,y) aus,
     * wobei es auf die angegebene Breite und H&ouml;he skaliert 
     * und um den Winkel phi gedreht wird.
     * 
     * @param g : das Graphics2D-Object
     * @param img : ddas Image-Objekt
     * @param x : die math. x-Koordinate
     * @param y : die math. y-Koordinate 
     * @param w : die Breite des Bildes in math. L&auml;nge
     * @param h : die H&ouml;he des Bildes in math. L&auml;nge
     * @param phi : der Drehwinkel in rad (Orientierung: gegen den Uhrzeige)
     */
    public void drawImage(Graphics2D g, Image img, double x, double y, double w, double h, double phi) {
        if (noneTr == null || tr == null && img != null) {
            return;
        }

        int width = (int) (w * unit);
        int height = (int) (h * unit);

        Image sizedImage = img.getScaledInstance(width, height, Image.SCALE_DEFAULT);
        
        if (sizedImage != null) {
            MediaTracker tracker = new MediaTracker(this);
            tracker.addImage(sizedImage, 0);
            try {
                tracker.waitForAll();
            } catch (InterruptedException e) {
                // do nothing?
            }

            // BoundingBox upper left
            float sx = (float) (x * unit + zeroX);
            float sy = (float) (zeroY - y * unit);
            float mx = sx + width/2;
            float my = sy + height/2;

            g.setTransform(noneTr);
            AffineTransform itr = new AffineTransform();
            itr.translate(mx, my); // Middle of Image
            itr.rotate(-phi); // mirrored in JMath -> negative!
            itr.translate(-mx, -my); // Back to Zero
            itr.translate(sx, sy); // BoundingBox upper left
            g.drawImage(sizedImage, itr, this);//, sx, sy);
            g.setTransform(tr);
        }
    }

    // Berechnen der Transformations-Kennzahlen basierend auf der aktuellen
    // Größe des Bildschirmbereichs und den Einstellungen der Einheiten und
    // der Nullstellen-Position
    private void initTransformation() {
        if (getSize().width <= 0 || getSize().height <= 0) {
            return;
        }

        if (zeroX < 4) {
            zeroX = 4;
        } else if (zeroX > getSize().width - 4) {
            zeroX = getSize().width - 4;
        }

        if (zeroY < 4) {
            zeroY = 4;
        } else if (zeroY > getSize().height - 4) {
            zeroY = getSize().height - 4;
        }

        mathMinX = -(double) zeroX / unit;
        mathMaxX = (double) (getSize().width - zeroX) / unit;
        mathMaxY = (double) zeroY / unit;
        mathMinY = -(double) (getSize().height - zeroY) / unit;
    }

    // Zeichnen der Achsen incl. PfeilspSizen und Markierungen pro Einheit
    private void drawAxis(Graphics2D g2d) {
        GeneralPath spitze = new GeneralPath();
        Line2D.Double linie;
        float spSize = 6.0f / unit;

        linie = new Line2D.Double(mathMinX, 0, mathMaxX, 0);
        g2d.draw(linie);
        linie = new Line2D.Double(0, mathMinY, 0, mathMaxY);
        g2d.draw(linie);

        spitze.moveTo((float) mathMaxX - spSize, 0);
        spitze.lineTo((float) mathMaxX - spSize, spSize / 2);
        spitze.lineTo((float) mathMaxX, 0);
        spitze.lineTo((float) mathMaxX - spSize, -spSize / 2);
        spitze.closePath();
        g2d.fill(spitze);

        spitze.moveTo(0, (float) mathMaxY - spSize);
        spitze.lineTo(spSize / 2, (float) mathMaxY - spSize);
        spitze.lineTo(0, (float) mathMaxY);
        spitze.lineTo(-spSize / 2, (float) mathMaxY - spSize);
        spitze.closePath();
        g2d.fill(spitze);

        double schritt;

        schritt = Math.floor(mathMinX);
        for (; schritt <= mathMaxX; schritt += 1) {
            linie = new Line2D.Double(schritt, -spSize / 2, schritt, spSize / 2);
            g2d.draw(linie);
        }

        schritt = Math.floor(mathMinY);
        for (; schritt <= mathMaxY; schritt += 1) {
            linie = new Line2D.Double(-spSize / 2, schritt, spSize / 2, schritt);
            g2d.draw(linie);
        }
    }

    /**
     * Gibt die Pixelanzahl der Strecke mit der math.
     * L&auml;nge 1 zur&uuml;ck
     *
     * @return Anzahl der Pixel der math. Strecke mit der L&auml;nge 1
     */
    public int getUnit() {
        return unit;
    }

    /**
     * Setzt die math. Einheit in Pixeln. Die Strecke mit der math.
     * L&auml;nge 1 hat anschlie&szlig;end die angegebene Pixel-L&auml;nge.
     *
     * @param pixel : Pixelanzahl der Strecke mit der math. L&auml;nge 1
     */
    public void setUnit(int pixel) {
        if (unit > 0) { // && unit < getSize().width &&  unit < getSize().height)
            if (this.unit != pixel)
                needRepaint = true;

            this.unit = pixel;
            if (needRepaint)
                repaint();
            needRepaint = false;
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    /**
     * Setzt ein Objekt, das aufgerufen wird, damit dort in den
     * math. Koordinaten gezeichnet werden kann.
     * 
     * Da Objekt muss die Schnittstelle MathPainter implementiert
     * haben!
     *
     * @param client - das aufzurufende Objekt
     */
    public void setPaintClient(MathPainter client) {

        this.paintClient = client;
    }

    /**
     * Gibt zur&uuml;ck, ob die Achsen angezeigt werden
     *
     * @return Achsen sichtbar (true/false)
     */
    public boolean isAxis() {

        return this.axis;
    }

    /**
     * Ein- oder ausschalten der Achsenansicht.
     *
     * @param axis - Anzeige der Achsen (true/false)
     */
    public void setAxis(boolean axis) {
        if (this.axis != axis)
            needRepaint = true;


        this.axis = axis;
        if (needRepaint)
            repaint();
        needRepaint = false;
    }

    /**
     * Gibt die x-Koordinate (in Pixeln) des math. Nullpunktes zur&uuml;ck
     * 
     * @return die x-Koordinate des math. Nullpunktes
     */
    public int getZeroX() {
        return zeroX;
    }

    /**
     * Setzt die x-Koordinate (in Pixeln) des math. Nullpunktes
     * 
     * @param x - die neue x-Koordinate des math. Nullpunktes
     */
    public void setZeroX(int x) {
        if (x != zeroX)
            needRepaint = true;

        this.zeroX = x;
        initTransformation();
            
        if (needRepaint)
            repaint();
        needRepaint = false;
    }

    /**
     * Gibt die y-Koordinate (in Pixeln) des math. Nullpunktes zur&uuml;ck
     * 
     * @return die y-Koordinate des math. Nullpunktes
     */
    public int getZeroY() {
        return zeroY;
    }

    /**
     * Setzt die y-Koordinate (in Pixeln) des math. Nullpunktes
     * 
     * @param y - die neue y-Koordinate des math. Nullpunktes
     */
    public void setZeroY(int y) {
        if (y != zeroY)
            needRepaint = true;

        this.zeroY = y;
        initTransformation();
            
        if (needRepaint)
            repaint();
        needRepaint = false;
    }

    /**
     * Setzt die Koordinaten (in Pixeln) des math. Nullpunktes
     * 
     * @param x - die neue x-Koordinate des math. Nullpunktes
     * @param y - die neue y-Koordinate des math. Nullpunktes
     */
    public void setZero(int x, int y) {
        if (x > 0 && x < getSize().width && y > 0 && y < getSize().height) {
            if (x != zeroX || y != zeroY)
                needRepaint = true;

            zeroX = x;
            zeroY = y;
            initTransformation();
            
            if (needRepaint)
                repaint();
            needRepaint = false;
        }
    }
    
    /**
     * Liefert die kleinste sichtbare math. x-Koordinate
     * 
     * @return mathMinX
     */
    public double getMathMinX() {
        return mathMinX;
    }

    /**
     * Liefert die gr&ouml;&szlig;ste sichtbare math. x-Koordinate
     * 
     * @return mathMaxX
     */
    public double getMathMaxX() {
        return mathMaxX;
    }

    /**
     * Liefert die kleinste sichtbare math. y-Koordinate
     * 
     * @return mathMinY
     */
    public double getMathMinY() {
        return mathMinY;
    }

    /**
     * Liefert die gr&ouml;&szlig;ste sichtbare math. y-Koordinate
     * 
     * @return mathMaxY
     */
    public double getMathMaxY() {
        return mathMaxY;
    }

    /**
     * Gibt an, ob die Maus benutzt werden kann, um den Nullpunkt
     * zu verschieben oder mit dem Mausrad die Unit zu verändern
     * 
     * @return true/false
     */
    public boolean isEnableMouse() {
        return enableMouse;
    }

    /**
     * Schaltet die Mausbenutzung ein oder aus. Ist sie eingeschaltet,
     * so kann der Nullpunkt verschoben werden oder mit dem Mausrad die
     * Unit verändert werden
     * 
     * @param enableMouse : true/false
     */
    public void setEnableMouse(boolean enableMouse) {
        this.enableMouse = enableMouse;
    }
}
